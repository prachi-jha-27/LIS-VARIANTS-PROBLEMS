3825. Longest Strictly Increasing Subsequence With Non-Zero Bitwise AND

ðŸ“Œ Problem Idea (High level)

We want to find the maximum length subsequence such that:

The bitwise AND of all elements in the subsequence is greater than 0

AND > 0 means at least one bit position is common (set) in all elements

ðŸ’¡ Key Observation

If a subsequence has AND > 0, then:

There exists at least one bit position i (0â€“30)

Every number in that subsequence must have bit i set

So instead of checking all subsequences:

Fix a bit i

Take all numbers that have this bit set

Among them, compute the Longest Increasing Subsequence (LIS)

We do this for all bit positions and take the maximum result.

ðŸ§  Function func â€” Longest Increasing Subsequence (LIS)
int func(vector<int>& nums) {
    vector<int> temp;
    for (int i = 0; i < nums.size(); i++) {
        auto idx = lower_bound(temp.begin(), temp.end(), nums[i]);
        if (idx != temp.end()) {
            *idx = nums[i];
        } else {
            temp.push_back(nums[i]);
        }
    }
    return temp.size();
}

ðŸ”¹ What this does

Implements LIS using Patience Sorting

temp[k] stores the minimum possible ending value of an increasing subsequence of length k+1

Uses lower_bound to keep temp sorted

ðŸ”¹ Time Complexity

O(N log N)

ðŸ” Main Function Logic
int longestSubsequence(vector<int>& nums) {
    int mx = 0;
    for (int i = 30; i >= 0; i--) {
        vector<int> temp;
        for (int j = 0; j < nums.size(); j++) {
            if (nums[j] & (1LL << i)) {
                temp.push_back(nums[j]);
            }
        }
        if (temp.empty())
            continue;
        mx = max(mx, func(temp));
    }
    return mx;
}

ðŸ”¹ Steps

Loop over all bit positions 0 â†’ 30

Collect numbers having the current bit set

Skip if no numbers match

Compute LIS for that subset

Update the global maximum

â± Overall Complexity

Bit loop: 31

Filtering numbers: O(N)

LIS per bit: O(N log N)

âœ… Total Time
O(31 Ã— N log N) â‰ˆ O(N log N)

âœ… Space
O(N)

####code#########

    int func(vector<int>& nums) {
        vector<int> temp;
        for (int i = 0; i < nums.size(); i++) {
            auto idx = lower_bound(temp.begin(), temp.end(), nums[i]);
            if (idx != temp.end()) {
                *idx = nums[i];
            } else {
                temp.push_back(nums[i]);
            }
        }
        return temp.size();
    }
    int longestSubsequence(vector<int>& nums) {
        int mx = 0;
        for (int i = 30; i >= 0; i--) {
            vector<int> temp;
            for (int j = 0; j < nums.size(); j++) {
                if (nums[j] & (1ll << i)) {
                    temp.push_back(nums[j]);
                }
            }
            if (temp.empty())
                continue;
                mx = max(mx, func(temp));
            
        }
        return mx;
    }
};
